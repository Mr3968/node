# 光照渲染立方体

* **平行光漫反射简单数学模型:漫反射光的颜色 = 几何体表面基色 * 光线颜色 * 光线入射角余弦值**
    - 几何体表面基色 简单的说就是不考虑 光照物体自身的颜色
    - (R2,G2,B2) = (R1,G1,B1) * (R0,G0,B0) * COSα
        - R2 = R1 * R0 * COSα
        - G2 = G1 * G0 * cosα
        - B2 = B1 * B0 * cosα

* **镜面反射简单数学模型: 镜面反射光的颜色 = 几何体表面基色 * 光纤颜色 * 视线与反射光线的夹角余弦值**

* 环境光照
    - **环境反射光颜色 = 几何体表面基色 * 环境光颜色**

* 复合光照
    - 使用光照模型的时候往往会使用多种光照模型,然后把每个光照模型颜色相乘的结果RGB分别相加,这时候要注意,多种模型的光照颜色相加后RGB的值要保证在区间[0,1],因为wegbgl的RGB颜色模型默认RGB分量的最大值为1
    - **总反射光线 = 漫反射光线 + 镜面反射光线 + 环境反射光线**

* 法向量
    - 在三维笛卡尔坐标系中,使用向量(x,y,z)来表示法向量可以根据几何体表面的法向量和光线的方向就可以求解出光线入射角的余弦值 着色器语言内置了dot用来求解两个向量之间的余弦值
    - 已知 a1(x1,y1,z1),a2(x2,y2,z2) 执行dot(a1,a2)可以求出两个向量a1,a2的余弦值

## 声明变量

* uniform关键字
    - uniform与attribute关键字的都是为了js可以想webgl着色器传递数据出现. 区别在于如果一个变量表示顶点相关的数据并且需要从js代码中获取顶点数据,需要使用attribute关键字声明该变量. 如果一个变量是非顶点相关的数据并且需要js传递该变量相关的数据, 需要使用uniform关键字声明该变量,比如上面代码通拓uniform关键字的光源位置变量u_lightPosition,光源颜色变量u_lightColor. 

* a_normal 
    - a_normal定义是的vec4类型，第四个参数默认是1.0主要是为了凑成齐次坐标用于矩阵计算，表示法向量方向的前三个参数，所以执行a_normal.xyz就相当于访问法向量的xyz值，返回的结果是一个vec3数据，如果执行ve3.xy相当于返回一个vec2数据，如果一个顶点的a_normal数据是（1.0，1.0，1.0，1.0）,那么他的模长就不是1而是3的平方根，这时候需要把前三个1全部除以3的平方根曹可以把非单位向量转化为单位向量

## 光照计算

* dot() 是webgl着色器语言的内置函数，他的参数是两个向量，执行结果是两个向量的点积，如果光线方向向量和顶点法向量两个向量都是单位向量，求解的结果就是平行光线与物体表面法线夹角的余弦值。内置函数normalize()和dot()一样是着色器语言提供的用于数学计算的函数，normalize()的作用就是把向量归一化，具体点说就是如果向量的模长不是1，不改变向量的方向，把模长变为1，也就是把向量转换为单位向量

* max() 函数表示两个参数取最大的值返回 min同理

* 余弦值是负值的物理意义就是光线无法照的地方，临界点是余弦值0，入射角是90°，也就是说入射光线平行平面，平行平面相当于光线没有照射到平面上，平面没有收到光自然无法反射光，可以尝试改变立方体顶点的旋转矩阵可以看到一些面的颜色是黑色，就是因为没有光线照射，这一点是复合实际生活和物理规律的，不管其本身是什么颜色，没有外界光源，那就表现为黑色  

* 注意**有的数据类型是ve3,以及vec4的数据类型 只有相同的数据类型才可以进行运算**

* 比如：u_lightColor * a_color.rgb * dot 是套用理想漫反射光照模型的一个公式进行计算，顶点颜色变量a_color是vec4类型包含了透明度，计算式中光源颜色变量u_lightColor没有透明度 所有使用a_color.rgb语句返回a_color变量的rgb三个分量，也就是返回一个vec3类型数据 然后再进行运算 

## 获取颜色变量

* 要想给着色器程序中声明的变量传递数据，首先要获取数据的地址，然后通过指针地址传递给变量。要想获取变量地址，不可能像普通CPU一样，需要考虑到GPU的特殊性，首先要调用初始化着色器函数 initShader() 把着色器程序处理后通过CPU与GPU的通信传递给GPU配置渲染管线，执行初始化着色器函数的同时会返回一个program对象，通过program可以获取着色器程序中的变量索引地址 通过WEBGL API gl.getAttributeLocation() 用来获取attribute 关键字声明的顶点变量地址，通过 WEBGL API gl.getUniformLocation() 获取uniform关键字声明的非顶点变量地址 

## 顶点法向量

* 对于立方来来说 六个平面那就需要6个不同的平面法向量，但是 这里要注意思考 如何表达一个面的法向量，你不能直接告诉GPU一个平面的法向量是（x,y,z），对于立方体来说这样比较简单，符合人的思维，但是如果是复杂的曲面这样并不合适，而且顶点着色器是逐顶点处理，为了表示面的法向量，往往是通过顶点，具体点说是每个顶点对应一个法向量，三个顶点确定一个三角面，三角面的不同位置的法向量是相当于通过他的三个顶点的法向量插值得出，或者换个说法就是三个顶点的法向量分别与各自颜色数据进行乘法运算，得到新的顶点数据，然后渲染管线利用新的顶点颜色进行插值计算，这就是通过顶点法向量表示面法向量的方法，通过这样巧妙设计还可以实现法向量插值计算，只不过插值是通过颜色插值完成的，对于平滑的曲面，过每个顶点存在一个法平面，也就是有一个法向量，往往再不同三角面中同一位置的顶点法向量是相同的，对于规则的长方体而言，每个顶点法向量往往在各自的平面中有不同的值

## 顶点法向量的矩阵变换

* 执行代码gl_Position = mx * my * apos 意味着通过旋转mx和my对立方体顶点数据apos进行旋转变换，也就是说立方体在三维空间中进行了旋转，如果立方体及逆行了旋转，也就是说立方体表面的法线方向变化了，立方体表面的法线是通过顶点法向量表示的，所以说顶点法向量数据要和顶点位置数据一样 执行矩阵变换mx * my * a_normal  

## 视线

* 代码中的灯光方向的向量数据，第三个参数是负数，也就是说从Z轴的角度看，平行光照射物体的方向，就是人眼睛看物体的方向，如果把灯光方向的向量数据Z参数更改为正数，刷新浏览器看到的是一个漆黑的立方体投影，这时候相当于黑暗的环境中，人站在物体的背光面，而不是向光面，对于WebGl 你可以形象的理解为把光源从屏幕前面放到了屏幕的后面，人的观察方向是沿着Z轴负方向 从屏幕外向里观察，光线自然被立方体遮挡住了