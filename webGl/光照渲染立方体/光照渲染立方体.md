# 光照渲染立方体

- **平行光漫反射简单数学模型:漫反射光的颜色 = 几何体表面基色 _ 光线颜色 _ 光线入射角余弦值**

  - 几何体表面基色 简单的说就是不考虑 光照物体自身的颜色
  - (R2,G2,B2) = (R1,G1,B1) _ (R0,G0,B0) _ COSα
    - R2 = R1 _ R0 _ COSα
    - G2 = G1 _ G0 _ cosα
    - B2 = B1 _ B0 _ cosα

- **镜面反射简单数学模型: 镜面反射光的颜色 = 几何体表面基色 _ 光纤颜色 _ 视线与反射光线的夹角余弦值**

- 环境光照

  - **环境反射光颜色 = 几何体表面基色 \* 环境光颜色**

- 复合光照

  - 使用光照模型的时候往往会使用多种光照模型,然后把每个光照模型颜色相乘的结果 RGB 分别相加,这时候要注意,多种模型的光照颜色相加后 RGB 的值要保证在区间[0,1],因为 wegbgl 的 RGB 颜色模型默认 RGB 分量的最大值为 1
  - **总反射光线 = 漫反射光线 + 镜面反射光线 + 环境反射光线**

- 法向量
  - 在三维笛卡尔坐标系中,使用向量(x,y,z)来表示法向量可以根据几何体表面的法向量和光线的方向就可以求解出光线入射角的余弦值 着色器语言内置了 dot 用来求解两个向量之间的余弦值
  - 已知 a1(x1,y1,z1),a2(x2,y2,z2) 执行 dot(a1,a2)可以求出两个向量 a1,a2 的余弦值

## 声明变量

- uniform 关键字

  - uniform 与 attribute 关键字的都是为了 js 可以想 webgl 着色器传递数据出现. 区别在于如果一个变量表示顶点相关的数据并且需要从 js 代码中获取顶点数据,需要使用 attribute 关键字声明该变量. 如果一个变量是非顶点相关的数据并且需要 js 传递该变量相关的数据, 需要使用 uniform 关键字声明该变量,比如上面代码通拓 uniform 关键字的光源位置变量 u_lightPosition,光源颜色变量 u_lightColor.

- a_normal
  - a_normal 定义是的 vec4 类型，第四个参数默认是 1.0 主要是为了凑成齐次坐标用于矩阵计算，表示法向量方向的前三个参数，所以执行 a_normal.xyz 就相当于访问法向量的 xyz 值，返回的结果是一个 vec3 数据，如果执行 ve3.xy 相当于返回一个 vec2 数据，如果一个顶点的 a_normal 数据是（1.0，1.0，1.0，1.0）,那么他的模长就不是 1 而是 3 的平方根，这时候需要把前三个 1 全部除以 3 的平方根曹可以把非单位向量转化为单位向量

## 光照计算

- dot() 是 webgl 着色器语言的内置函数，他的参数是两个向量，执行结果是两个向量的点积，如果光线方向向量和顶点法向量两个向量都是单位向量，求解的结果就是平行光线与物体表面法线夹角的余弦值。内置函数 normalize()和 dot()一样是着色器语言提供的用于数学计算的函数，normalize()的作用就是把向量归一化，具体点说就是如果向量的模长不是 1，不改变向量的方向，把模长变为 1，也就是把向量转换为单位向量

- max() 函数表示两个参数取最大的值返回 min 同理

- 余弦值是负值的物理意义就是光线无法照的地方，临界点是余弦值 0，入射角是 90°，也就是说入射光线平行平面，平行平面相当于光线没有照射到平面上，平面没有收到光自然无法反射光，可以尝试改变立方体顶点的旋转矩阵可以看到一些面的颜色是黑色，就是因为没有光线照射，这一点是复合实际生活和物理规律的，不管其本身是什么颜色，没有外界光源，那就表现为黑色

- 注意**有的数据类型是 ve3,以及 vec4 的数据类型 只有相同的数据类型才可以进行运算**

- 比如：u_lightColor _ a_color.rgb _ dot 是套用理想漫反射光照模型的一个公式进行计算，顶点颜色变量 a_color 是 vec4 类型包含了透明度，计算式中光源颜色变量 u_lightColor 没有透明度 所有使用 a_color.rgb 语句返回 a_color 变量的 rgb 三个分量，也就是返回一个 vec3 类型数据 然后再进行运算

## 获取颜色变量

- 要想给着色器程序中声明的变量传递数据，首先要获取数据的地址，然后通过指针地址传递给变量。要想获取变量地址，不可能像普通 CPU 一样，需要考虑到 GPU 的特殊性，首先要调用初始化着色器函数 initShader() 把着色器程序处理后通过 CPU 与 GPU 的通信传递给 GPU 配置渲染管线，执行初始化着色器函数的同时会返回一个 program 对象，通过 program 可以获取着色器程序中的变量索引地址 通过 WEBGL API gl.getAttributeLocation() 用来获取 attribute 关键字声明的顶点变量地址，通过 WEBGL API gl.getUniformLocation() 获取 uniform 关键字声明的非顶点变量地址

## 顶点法向量

- 对于立方来来说 六个平面那就需要 6 个不同的平面法向量，但是 这里要注意思考 如何表达一个面的法向量，你不能直接告诉 GPU 一个平面的法向量是（x,y,z），对于立方体来说这样比较简单，符合人的思维，但是如果是复杂的曲面这样并不合适，而且顶点着色器是逐顶点处理，为了表示面的法向量，往往是通过顶点，具体点说是每个顶点对应一个法向量，三个顶点确定一个三角面，三角面的不同位置的法向量是相当于通过他的三个顶点的法向量插值得出，或者换个说法就是三个顶点的法向量分别与各自颜色数据进行乘法运算，得到新的顶点数据，然后渲染管线利用新的顶点颜色进行插值计算，这就是通过顶点法向量表示面法向量的方法，通过这样巧妙设计还可以实现法向量插值计算，只不过插值是通过颜色插值完成的，对于平滑的曲面，过每个顶点存在一个法平面，也就是有一个法向量，往往再不同三角面中同一位置的顶点法向量是相同的，对于规则的长方体而言，每个顶点法向量往往在各自的平面中有不同的值

## 顶点法向量的矩阵变换

- 执行代码 gl_Position = mx _ my _ apos 意味着通过旋转 mx 和 my 对立方体顶点数据 apos 进行旋转变换，也就是说立方体在三维空间中进行了旋转，如果立方体及逆行了旋转，也就是说立方体表面的法线方向变化了，立方体表面的法线是通过顶点法向量表示的，所以说顶点法向量数据要和顶点位置数据一样 执行矩阵变换 mx _ my _ a_normal

## 视线

- 代码中的灯光方向的向量数据，第三个参数是负数，也就是说从 Z 轴的角度看，平行光照射物体的方向，就是人眼睛看物体的方向，如果把灯光方向的向量数据 Z 参数更改为正数，刷新浏览器看到的是一个漆黑的立方体投影，这时候相当于黑暗的环境中，人站在物体的背光面，而不是向光面，对于 WebGl 你可以形象的理解为把光源从屏幕前面放到了屏幕的后面，人的观察方向是沿着 Z 轴负方向 从屏幕外向里观察，光线自然被立方体遮挡住了

## 立方体添加点光源

* 添加平行光是直接定义光线照射物体的方向，点光源的光线是发散的，无法直接定义它的光线方向，不过只要是定义好点光源的位置坐标，然后与某个顶点的位置坐标进行减法运算，计算结果就是光源射到该顶点的方向。 在三维空间中两点确定一条直线，几何体顶点代表一个点，点光源的位置代表一个点，直线所在的方向就是光线的方向，在三维笛卡尔坐标系中，把两个顶点的 xyz 的三个分量相减就可以得到一个表示直线方向的向量，把该向量和顶点法向量作为 dot()点积函数的参数，可以计算出光线入射角余弦值然后代入漫反射光照模型公式可以得到新的顶点颜色，渲染管线利用新的顶点颜色进行插值计算可以得到立方体表面每一个像素的值  

* WebGL 顶点着色器声明两个变量u_lightPosition、u_lightColor分别表示光源的位置和颜色 
    - 点光源颜色变量
        - uniform vec3 u_lightColor 
    - 点光源位置变量
        - uniform vec3 u_lightPosition 

* 给点光源颜色变量u_lightColor、位置变量u_lightPosition传递数据
    - gl.uniform3f(u_lightColor,1.0,1.0,1.0);
    - gl.uniform3f(u_lightPosition,2.0,3.0,4.0);

* 点光源与顶点方向计算
    - 点的光源的光线是发散的， 点光源与每一顶点连线的方向都需要单独计算
    - vec3(gl.Position) - u_lightPosition用来计算光线方向，然后利用内置函数normalize()归一化向量数据，vec3(gl_Position)和gl.Position.xyz的写法是等效的，都是为了提取vec4类型顶点数据前三个分量，返回的数据类型是vec3，比如vec2(vec4)就是提取vec4的前两个分量  