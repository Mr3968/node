# 从浏览器多进程到 JS 单线程

- 进程与线程
  - 进程是 cpu 资源分配最小的单位（系统为给他分配内存）
  - 线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

**不同进程之间也可以通信，不过代价比较大。**
**现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多（所以核心还是得属于一个进程才行）**

## 浏览器是多进程的

- 浏览器是多进程的

- 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu,内存）

- 简单点理解，每打开一个 Tab 页，就相当于创建了一个独立的浏览器进程。
  - **在这里浏览器应该也有自己的优化机制，有时候打开多个 Tab 页后，可以在 Chrome 任务管理器中看到，有些进程被合并了**

## 浏览器有那些进程

- Browser 进程：浏览器的主要进程（负责协调，主控），只有一个。作用有

  - 负责浏览器界面显示，与用户交互。如前进，后退等
  - 负责各个页面的管理，创建和销毁其他进程
  - 将 Render 进程得到的内存中的 Bitmap，绘制到用户界面上
  - 网络资源的管理，下载等

- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件的时候才创建

- GPU 进程: 最多一个，用于 3D 绘制等

- 浏览器渲染进程（浏览器内核）（Renderer 进程，内部是多线程的）：默认每个 Tab 页面一个进程，互不影响。主要作用为
  - 页面渲染，脚本执行，事件处理等

## 浏览器多进程的优势

- 避免单个 page crash（崩溃）影响整个浏览器

- 避免第三方插件 crash 影响整个浏览器

- 多进程充分利用多核优势

- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

### 浏览器沙盒模型（沙箱模型）（SandBox）

- 背景：对于网络上的网页，浏览器认为他们是不安全的，因为网页总是存在各种可能性，也许是无意的或有意的攻击。如果他有一种机制，将网页的运行限制在一个特定的环境种，也就是一个沙箱种，使他只能访问有限的功能。那么，即使网页工作的渲染引擎被攻击，它也不能够渲染引擎工作的主机系统中的任务权限，这一思想就是沙箱模型

- 原理：沙盒技术与主动防御技术原理截然不同。

  - 主动防御技术是发现有程序有可疑行为时立即拦截并终止运行。
  - 沙盒技术则是发现可以行为后让程序继续运行，当发现的确是病毒是才会停止。
  - 沙盒技术的实践运用流程是：让疑似病毒文件的可疑行为在虚拟的沙盒里充分表演，沙盒会去记下他的每一个动作；当疑似病毒充分暴露了其病毒属性后，沙盒就会执行回滚机制：将病毒的痕迹和动作抹去，恢复系统到正常状态
  - 沙盒的魅力就在于他允许你出错，还可以给你改正的机会。

- 沙箱模型工作的基本单位就是进程。每一个进程对应一个沙箱。

## 浏览器内核（渲染进程）

* 渲染进程是多线程的

* GUI 渲染线程
  - 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。
  - 当界面需要重绘或由于某种操作引发回流时，该线程就会执行
  - **GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行**

* JS引擎线程
    - 也称为JS内核负责处理Js脚本程序
    - JS引擎线程负责解析js脚本，运行代码
    - JS引擎一直子等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS线程在运行JS程序
    - 因为GUI渲染线程于JS引擎线程是互斥的 所以如果JS执行的时间过长，这样就回造成页面的渲染不连贯，导致页面渲染加载阻塞

  * 事件触发线程
    - 归属于浏览器而不是JS引擎，用来控制事件循环
    - 当JS引擎执行代码块 如setTimeOut时（也可来自浏览器内核的其他线程，如鼠标点击，AJAX异步请求等，会将对应任务添加到事件线程中）
    - 当对应的事件符合触发条件被触发时，该线程会吧事件添加到待处理队列的队尾，等待JS引擎的处理
    - 注意，由于js的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才回去执行）

  * 定时触发器线程
    - ```setInterval,setTimeOut```所在的线程
    - 浏览器当时计数器并不是由Js引擎技术的 （因为js引擎是单线程的如果处于阻塞线程状态就回影响计时的准确）
    - 因此通过单独线程来计时并触发定时
    - **W3C在HTML标准中规定，规定要求setTimeOut中低于4ms的时间间隔算4ms**

  * 异步请求http线程
    - 在XMLHttpRequest在连接后通过浏览器新开一个线程请求
    - 将检测到状态变更的时候，如果设置有回调函数，异步线程就回产生状态变更事件，将这个回调再放入事件队列中。在由js引擎执行


## Brower进程和浏览器内核（Render进程）的通信过程

* Brower进程收到用户请求，首先需要获取页面内容（比如通过网络下载资源）随后将该任务通过RenderHost接口传递给Render进程

* Render进程的Render接口收到消息，简单解释后，交给渲染线程，然后开始渲染
  - 渲染线程接受请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染
  - 当然可能会有JS线程来操作DOM
  - 最后Render进程将结果传递给Broswer进程

* Broser进程接收到结果并将结果绘制出来


## 浏览器内核中线程之间的关系

* GUI渲染线程与JS引擎线程互斥
  - 因为js是可以操纵DOM的，如果在修改这些元素属性同时渲染界面（js线程和UI线程同时运行）那么渲染线程前后获得的元素数据可能不一致
  - 所以浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起
  - GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即执行

* JS阻塞页面加载
  - 从上述的关系可以看出 js执行时间过长就会阻塞页面
  - 假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行
  - 由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉卡
  - 所以要尽量避免JS执行时间过程，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉


## 浏览器渲染流程

* 浏览器输入url，浏览器主进程接管，开一个下载进程 然后进行http请求（略去了DNS查询，IP寻址等操纵），然后等待相应，获取内容随后将通过RenderHost接口转交给Renderer进程

* 浏览器渲染浏览开始

  - 解析html建立DOM树
  - 解析css构建render树（将css代码解析成树形的数据结构，然后结合DOM合并render树）
  - 布局render树，负责各元素尺寸，位置计算
  - 绘制render树，绘制页面像素信息
  - 浏览器会将各层的信息发送给GPU，GPU将各层合成，显示在屏幕上
  - 渲染就会毕了 就会去触发load事件

* **load事件与DOMContentLoaded事件的先后**
  - 当DOMContentLoaded事件触发时，仅当DOM完成加载，不包括样式表，图片
  - 当onload事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成

* **css加载是否会阻塞dom树的渲染**
  - css是由单独的下载线程下载的
  - css不会去阻塞dom树的解析
  - 但会阻塞render树的渲染
    - 一种优化 因为render树的基于css的信息来渲染 
  
* 普通图层和复合图层
  - 浏览器渲染的图层一般包含两大类：普通图层以及复合图层

  - 普通文档流内可以理解为一个默认复合图层，其次absolute布局也一样 虽然可以脱离普通文档流，但它依然是属于复合图层

  - 通过硬件加速的方式，声明一个新的复合图层，他会单独分配资源

  - GPU中，各个复合图层是单独绘制的，所以互不影响

* **absolute和硬件加速的区别**
  - absolute虽然可以脱离普通文档流，但是无法脱离默认复合层
  - 所以就算absolute中信息不会改变普通文档流中render树
  - 但是，浏览器最终绘制的时候，是整个复合层绘制的，所以absolute中信息的改变，还是会影响整个复合层的绘制

* 硬件加速时请使用index
  - 如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意

