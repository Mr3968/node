# 作用域

**该文章只会查缺不漏以及强调 不会统一的记录全部内容**

## 编译原理

- 程序中的一段源码代码在执行之前会经历三个步骤，统称为“ 编译 ”
  - 分词/词法分析
    - 这个过程会将字符组成的字符串分解成（对编程语言来说）有意义的代码块。这些代码快被称为词法单元。例如 考虑程序 var a = 2; 这段程序通常会被分解成下面这些词法单元： `var 、a、2、;、`空格是否会被当做词法单元 取决于空格在这门语言中是否具有意义
  - 解析/语法分析
    - 这个过程是将词法单元流（数组）转换成为一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“ 抽象语法树 （AST）”
  - 代码生成
    - 将 AST 转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等信息相关
    - 抛开具体的细节来讲 简单的说就是有某种方法可以将`var a = 2;`的 AST 转换为一组机器指令，用来创建一个叫做 a 的变量（包括分配内存等）并将一个值储存在 a 中

* 比起那些编译过程只有以上三个步骤的语言的编译器，js 引擎要复杂的多，例如在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等

- js 的编译是发生在 js 执行前的几微秒（甚至更短） （预执行阶段）

- js 引擎用尽了各种办法（比如 JIT，可以延迟编译甚至实施重编译）来保证性能的最佳

- 例子： 对于`var a = 2;`来说 这段代码 编译器会怎么执行

  - 1. 遇到 var a ，编译器会询问作用域是否已经有一个该名称的变量存在于用一作用域的集合中，如果是，编译器会忽略该变量的声明,继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a

  - 2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做 a 的变量，如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量

  - 3. 如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常

- 对于上述例子来说 引擎执行它时，会通过查找变量来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果

- 在我们的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找的类型叫做 RHS

- 词法作用域查找只会查找一级标识符

- 对于 eval 以及 with 使用的性能问题
  - 在运行时 eval 和 with 会创建新的作用域，以此来欺骗其他在书写时定义的词法作用域
  - js 引擎会在编译阶段数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符，但是如果引擎在代码中发现了 eval(...),或 with() 它只能简单地假设过于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval（）会接受什么样的代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词发作用域的对象的内容到底是什么
  - 最悲观的情况就是所有的优化都可能是无效的
  - 如果代码大量使用了 eval 或者 with 那么运行起来一定会变得非常慢

### LHS RHS

- 简单的来说，当变量出现在赋值操作的左侧时 进行 LHS 查询，出现在右侧时进行 RHS 查询

- 讲的更加准确一点，RHS 查询与简单地查找某个变量的值无二区别，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“ 赋值操作的右侧 ” ，更准确的来说应该是“ 非左侧 ”

- **对于 obj.a.fn() 这种情况 只会对 obj 进行一次 RHS 访问 不会对 a 在进行一次访问 因为得到的 a 会由对象属性访问规则会分别来接管对于 a 以及 fn 的访问**

- 为什么要去区分 LHS 以及 RHS 两种查询方式

  - 因为在变量还没有声明的时候，这两种查询的行为是不一样的
  - 如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出一个 ReferenceError 异常。值得注意的是，ReferenceError 是非常重要的异常类型
  - LHS 查询时，如果在顶层中也无法找到目标变量，全局作用中就会去创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非严格模式下

- 如果 RHS 查询到了一个变量，但是你尝试对这个变量进行不合理的操作那么引擎就会抛出 TypeError

- ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了， 但是对结果的操作是非法或不合理的

### JIT

- JIT 编译：侠义来说是当某段代码即将第一次被执行时及逆行编译，因而叫“ 即时编译 ” JIT 编译是动态编译的一种特例，JIT 编译一次后来被泛化，时常与动态编译等价；但要注意广义与侠义的 JIT 编译所指的区别

- 动态编译

  - 指的是“ 在运行是进行编译 ” ；与之相对的是事前编译（AOT） 也叫静态编译

- 自适应动态编译
  - 也是一种动态编译 但它通常执行的实际比 JIT 编译迟 先让程序“ 以某种式 ”运行起来，收集一些信息之后在做动态编译。这样的编译可以更加优化

## 对象

- 在对象中，属性名永远都是字符串，即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在对象属性名中数字回被转换成字符串，所以当心不要搞混对象和数组中，数字的用法

### 属性描述符

- writable 可写
  - 决定是否可以修改属性的值
- enumerable 可枚举
  - 设置为 false 这个属性就不会出现在 for..in 循环中，就不会出现在枚举中，虽然任然可以正常访问它
- configurable 可配置

  - 只要属性是可配置的 就可以使用 definePropety 方法来修改属性描述符
  - **即使属性是 configurable:false，我们还是可以吧 writable 的状态由 true 改为 false,但是无法由 false 改为 true**
  - 设置未 fasle，除了无法修改，还会禁止去删除这个属性

- 结合 writable 与 enumrable 就可以创建一个真正的常量属性（不可修改、重定义或者删除）

- 禁止扩展

  - 如果你想禁止添加新属性，并且保留已有属性，可以使用 Object.preventExtensions(obj)
  - 如果添加了 在非严格模式下会 undefined 严格模式下会报错

- 密封

  - Object.seal()会创建一个密封对象，这个方法实际上会在一个现有对象上调用 Object.preventExtensions()并把所有现有属性标记为 configurable:false
  - 所以密封之后不仅不能添加新的属性，也不能重新配置或者删除任何现有属性（但是可以修改属性的值）

- 冻结
  - Object.freeze()会创建一个冻结对象，这个方法实际上回在一个现有对象上调用 Object.seal()并把所有数据访问属性标记为 false (writable:fasle)，这样就无法修改他们的值

- [[Get]]
  - 