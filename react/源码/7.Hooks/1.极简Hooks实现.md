# 极简Hooks实现

* 对于useState Hook
```
function App() {
  const [num, updateNum] = useState(0);

  return <p onClick={() => updateNum(num => num + 1)}>{num}</p>;
}
```

* 可以将工作分为两部分：
    - 通过一些途径产生更新，更新会造成组件render
    - 组件render时useState返回的num为更新后的结果

* 其中步骤1的更新可以分为mount和update：
    - 调用ReactDOM.render会产生mount的更新，更新内容为useState的initiaValue（即0）
    - 点击p标签出发updateNum会产生一次update的更新，更新内同为num => num + 1

## 更新是什么

* 首先要明确更新是什么

* 在我们的极简例子中，更新就是如下数据结构：
```
const update = {
  // 更新执行的函数
  action,
  // 与同一个Hook的其他更新形成链表
  next: null
}
```

* 对于App来说,点击p标签产生的update的action为num => num + 1

* 如果改写App的onClick：
```
// 之前
return <p onClick={() => updateNum(num => num + 1)}>{num}</p>;

// 之后
return <p onClick={() => {
  updateNum(num => num + 1);
  updateNum(num => num + 1);
  updateNum(num => num + 1);
}}>{num}</p>;
```

* 那么点击p标签就会产生3个update

## update数据结构

* 这些update会组成一个环状单向链表

* 调用setState实际上调用的函数是 dispatchAction.bind(null,hook,queue) 

```

function dispatchAction(queue, action) {
  // 创建update
  const update = {
    action,
    next: null
  }

  // 环状单向链表操作
  if (queue.pending === null) {
    update.next = update;
  } else {
    update.next = queue.pending.next;
    queue.pending.next = update;
  }
  queue.pending = update;

  // 模拟React开始调度更新
  schedule();
}

```
  - 当产生一个update(u0) 此时 queue.pending === null
  - update.next = update (u0.next = u0) 他会和自己首尾相连形成单向环状链表
  - 然后queue.pending = update 即（queue.pending = u0） 

  - 当产生第二个update(u1), update.next = queue.pending.next (此时queue.pending.next = u0) u1.next = u0
  - queue.pending.next = update 即 u0.next = u1
  - 然后queue.pending = update 即queue.pending = u1

* 当出入多个update的情况 会发现queue.pending始终只想最后一个插入的update

* 这样做的好处是，当我们要遍历update时，queue.pending.next指向插入的update 

## 状态如何保存


