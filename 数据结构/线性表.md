# 线性表

- 由同类型数据元素构成有序序列的线性结构

  - 表中元素个数称为线性表的长度
  - 线性表没有元素时，称为空表
  - 表起始位置称表头，表结束位置称表尾

- 由零个或多个数据元素组成的有限序列
  > 关键词：序列
  - 也就是说元素之间是有个先来后到的
  - **若元素存在多个，则第一个元素无前驱，而最后一个无后继，其他元素有且只有一个前驱和后继**
  - 线性表的强调是有限的

## 抽象数据类型

- 抽象：

  - 是指抽取除事物具有的普遍性的本质。它要求抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节

- 对已有的数据类型进行抽象，就有了抽象数据类型

- 抽象数据类型
  - （Abstract Data Type ADT） 是指一个数学模型及定义在该模型上的一组操作

> 线性表的抽象数据类型描述

- 类型名称：线性表
- 数据对象集：线性表是 n(>=0)个元素构成的有序序列，第一个元素无前驱，而最后一个无后继，其他元素有且只有一个前驱和后继
- 操作：

  - initList: 初始化操作
  - listEmpty:判断线性表是否为空表
  - clearList:将线性表清空
  - getElem:将线性表中的第 i 个位置元素返回
  - locateElem:在线性表中查找与给定值 e 相等的元素 查找成功返回该元素在表中序号表示成功，否则 0 表示返回失败
  - listInsert：在线性表 L 中第 i 个元素插入新元素 e
  - listDelete: 删除第 i 个
  - listLength：list 的元素个数

- 线性表的起始位置是 1

## 线性表的顺序存储结构

- 线性表的两种物理存储结构：
  - 顺序存储解结构
  - 链式存储结构

### 顺序存储结构

- 顺序存储结构指的是用一段地址连续的存储单元一次存储线性表的数据元素

- 物理上的存储方式事实上就是在内存中找个初始地址，然后通过占位的形式，把一定的内存空间给占了 然后把相同数据类型的数据元素依次放在这块空地中

- 顺序储存结构封装需要三个属性

  - 存储空间的起始位置，数组 data，它的存储位置就是线性表存储空间的存储位置
  - 线性表的最大存储容量：数组的长度 MaxSize
  - 线性表的当前长度：length

- **注意：数组的长度与线性表的当前长度需要区分，数组的长度是存放线性表的存储空间的总长度，一般初始化后不变，而线性表的当前长度是线性表中元素的个数，是会变化的**

- 线性表的顺序存储结构，在存，读数据时，不管是哪个位置，时间复杂度都是 o(1)。而在插入或删除 时间复杂度都是 o(n)

- 优点
  - 无须为表示表中元素之间的逻辑关系而增加额外的存储空间
  - 可以快速存储表中任意位置的元素
- 缺点
  - 插入和删除操作需要移动大量元素
  - 当线性表长度变化较大时，难以确定存储空间的容量
  - 容易造成存储空间的碎片

## 线性表的链式存储结构 --- 单链表

- 线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以存在内存中未被占用的任意位置

- 比起顺序存储结构每个数据元素只需要存储一个位置就可以了。现在链式存储结构中，除了要存储数据元素信息外，还要存储它的后继元素的存储地址（指针）

- 把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称为指针或链。这两部分信息组成数据元素称为存储映像 称为结点

- n 个结点链接成一个链表 即为线性表的链式存储结构

- 因为此链表的每个结点中只包含一个指针域，所以叫做单链表

- 链表中的第一个结点的存储位置叫做头指针，最后一个结点指针为空

- 头结点的数据域一般不存储信息

- **头结点与头指针的区别？**

  - 头指针
    - 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针
    - 头指针具有标识作用，所以常用头指针冠以链表的名字（指针变量的名字）
    - 无论链表是否为空，头指针均不为空
    - 头指针是链表的必要元素
  - 头结点
    - 头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义（但也可用来存放链表的长度）
    - 有了头结点，对在第一元素结点前插入结点和删除结点操作就统一了
    - 头结点不是链表的必要元素

- 单链表的插入 删除等其他操作时间复杂度都是 o(n)

- 与顺序链表相比优势在于 顺序链表如果想要一次性插入 10 个元素 对于元素存储结构意味着每次插入都需要移动 n - i 个位置，所以每次都是 o(n)

- 而单链表 只需要在第一次时，找到第 i 个位置的指针，此时为 o(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是 o(1)

### 单链表的整表创建

- 单链表和顺序存储结构就不一样，不像顺序存储结构数据那么集中，它的数据可以是分散在内存的各个角落的，它的增长也是动态的

- 对于每个链表来说，它所占用的大小和位置是不需要预先分配划定的，可以根据系统的情况和实际的需求即使生成

- 创建单链表的过程是一个动态生成链表的过程，从空表的初始状态起，依次建立各元素结点并逐个插入链表

- 所以单链表整表创建的算法思路如下：

  - 声明一结点 P 和计数器变量 i
  - 初始化一空链表 L
  - 让 L 的头结点的指针指向 null，即建立一个带头结点的单链表

- **头插法建立单链表**

- 头插法从一个空表开始，生成新结点，读取数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头上，知道结束为止

- 简单来说，就是把新加进的元素放到表头后的第一个位置：

  - 先让新节点的 next 指向头结点之后
  - 然后让表头的 next 指向新结点、
  - 缺点：生成的链表中结点的次序和输入是顺序相反

- 同理也有尾插法建立单链表

- **单链表的整表删除**

  - 在 c 语言中 内存所需子集手动释放

- **单链表结构与顺序存储结构优缺点**

  - 存储分配方式
    - 顺序存储结构用一段连续的存储单元依次存储线性表的数据
    - 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素
  - 时间性能：
    - 查找
      - 顺序存储结构 o(1)
      - 单链表 o(n)
    - 插入和删除
      - 顺序存储结构需要平均移动表长一半的元素(平均来说)，时间为 o(n)
      - 单链表在计算出某位置的指针后，插入和删除时间仅为 o(1)
  - 空间性能
    - 顺序存储结构需要预分配存储空间，分大了，容易造成空间浪费，分小了，容易发生溢出
    - 单链表不需要分配存储空间，只要有就可以分配，元素个数不受限制

- 总结：
  - 若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构
  - 若需要频繁插入和删除时，宜采用单链表结构

## 静态链表

- 用数组描述的链表叫做静态链表，这种描述方法叫做游标实现法

- 所以静态链表实际上就是数组，由下标，数据，游标组成

- 约定：

  - 数组的第一个元素的游标指向数组中第一个没有存放数据的下标，
  - 数组的最后一个元素的游标指向的是数组中第一个存放数据的下标
  - 存放数据的最后一个元素的游标一定要指向 0 不然查找一直不会结束

- 游标的值就是下标 依次指向下一个数据的下标（单链表）

- 没有使用数据的数组元素称为备用链表

- 静态链表与单链表是很相似的 只是用数组来模拟的

## 快慢指针

- 设置两个指针 *search,*mid 都指向单链表的头结点，其中 * search 的移动速度是 *mid 的 2 倍，当 *search 指向末尾结点的时候，mid 正好就在中间了这也是标尺的思想


## 循环链表

- 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表成为单循环链表，简称循环链表

- 循环链表同样不一定有头结点

- 循环链表判断空链表是head->next === head

- 特点：
  - 访问最后一个为o(1)
  

### 约瑟夫问题

- 用循环链表模拟约瑟夫问题 把41个人自杀的顺序编号输出？

- 编号为1~n的N个1个人按顺时针方向围坐一圈，每个人持有一个密码（正整数，可以自由输入），开始人选一个正整数作为报数上限值M，从第一个人按顺时针开始报数，报M的人出列，将它的密码作为新的M值，从他顺时针方向上的下一人开始从1报数，如此直至所有人全部出列为止 

### 判断单链表中是否存在环的问题
- 思路就是 两个指针一个每次都只走一步  一个每次都从头走 当第二个指针与第一个指针相等但是步骤缺不一致的时候 就说明了存在环

- 思路2：快慢指针 若存在环总会存在 p === q

### 魔术师发牌问题

- 第一张为A 数两张第二张翻开为2 数三张第三张翻开为3....模拟出这13张牌的放置顺序 怎样才能完成这样

### 拉丁方阵问题

- 拉丁方阵是一种n*n的方阵，方阵中恰有n种不同的元素，每种元素恰有n个，并且每种元素在一行和一列种 恰好出现一次。

- 例如：
 1 2 3
 2 3 1
 3 1 2

### 双向链表

- 每个结点多了一个前驱结点的指针

- 同样双向链表也有循环链表

- 提高算法的时间性能 用空间换取时间